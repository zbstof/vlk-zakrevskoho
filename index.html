<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ü—Ä–æ–≥–Ω–æ–∑ —á–µ—Ä–≥–∏ –í–õ–ö</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jstat/1.9.6/jstat.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chartjs-plugin-zoom/2.0.1/chartjs-plugin-zoom.min.js"></script>
    <style>
        body { font-family: sans-serif; margin: 20px; }
        #loading { font-style: italic; color: #666; }
        #chart-container { position: relative; height: 80vh; width: 100%; }
        .error { color: red; font-weight: bold; }
    </style>
</head>
<body>
    <h1>–ü—Ä–æ–≥–Ω–æ–∑ —á–µ—Ä–≥–∏ –í–õ–ö –Ω–∞ –ó–∞–∫—Ä–µ–≤—Å—å–∫–æ–≥–æ 81/1</h1>
    <div id="loading">–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –¥–∞–Ω–∏—Ö –∑ Google –¢–∞–±–ª–∏—Ü—ñ...</div>
    <div id="error" class="error"></div>
    
    <div style="margin-bottom: 10px; display: flex; align-items: center; gap: 10px;">
        <input type="number" id="queueInput" placeholder="–í–≤–µ–¥—ñ—Ç—å –Ω–æ–º–µ—Ä —á–µ—Ä–≥–∏" style="padding: 5px; width: 150px;">
        <button id="findBtn" style="padding: 5px 10px; cursor: pointer;">–ü–æ–∫–∞–∑–∞—Ç–∏ –ø—Ä–æ–≥–Ω–æ–∑</button>
        <button id="resetZoomBtn" style="padding: 5px 10px; cursor: pointer;">–°–∫–∏–Ω—É—Ç–∏ –∑—É–º</button>
        <span style="margin-left: auto; color: #555; font-style: italic;">üëâ –ù–∞—Ç–∏—Å–Ω—ñ—Ç—å –Ω–∞ –≥—Ä–∞—Ñ—ñ–∫ —â–æ–± –ø–æ–±–∞—á–∏—Ç–∏ –π–º–æ–≤—ñ—Ä–Ω–æ—Å—Ç—ñ –ø–æ—á–∞—Ç–∫—É –í–õ–ö</span>
    </div>

    <div id="chart-container">
        <canvas id="queueChart"></canvas>
    </div>
    
    <div style="margin-top: 10px; font-style: italic; color: #666; font-size: 0.9em;">
        –ü—Ä–∏–º—ñ—Ç–∫–∞: –ü–æ–ø–µ—Ä–µ–¥–Ω—ñ –∑–∞–ø–∏—Å–∏ –Ω–∞ –¥–∞—Ç–∏, —â–æ –≤—ñ–¥–¥–∞–ª–µ–Ω—ñ –±—ñ–ª—å—à –Ω—ñ–∂ –Ω–∞ 3 –º—ñ—Å—è—Ü—ñ –≤—ñ–¥ –ø–æ—Ç–æ—á–Ω–æ—ó –¥–∞—Ç–∏, –Ω–∞ –≥—Ä–∞—Ñ—ñ–∫—É –Ω–µ –≤—ñ–¥–æ–±—Ä–∞–∂–∞—é—Ç—å—Å—è.
    </div>

    <script type="module">
        import { parse } from 'https://cdn.jsdelivr.net/npm/csv-parse@5.5.3/+esm';
        
        // Google Sheet CSV URL
        const SHEET_ID = '1d9OG-0b7wxxqrOujC9v6ikhjMKL2ei3wfrfaG61zSjA';
        const STATS_SHEET = '822507513';
        const HISTORICAL_DATA_SHEET = '84071606';
        
        const statsUrl = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/export?format=csv&gid=${STATS_SHEET}`;
        const historicalDataUrl = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/export?format=csv&gid=${HISTORICAL_DATA_SHEET}`;

        const isLocalhost = window.location.hostname === 'localhost' || 
                            window.location.hostname === '127.0.0.1' ||
                            window.location.protocol === 'file:';

        const STATS_URL = isLocalhost 
            ? 'https://corsproxy.io/?' + encodeURIComponent(statsUrl) 
            : statsUrl;
        const HISTORICAL_DATA_URL = isLocalhost 
            ? 'https://corsproxy.io/?' + encodeURIComponent(historicalDataUrl) 
            : historicalDataUrl;

        // --- Helper Functions ---
        function fetchAndParse(url) {
            return fetch(url)
                .then(response => response.text())
                .then(csvText => {
                    return new Promise((resolve, reject) => {
                        const options = url.includes(HISTORICAL_DATA_SHEET)
                            ? { columns: true, skip_empty_lines: true, from_line: 3 }
                            // url.includes(STATS_SHEET)
                            : { columns: true, skip_empty_lines: true };
                        
                        parse(csvText, options, (err, records) => {
                            if (err) reject(err);
                            else resolve(records);
                        });
                    });
                });
        }

        function parseDate(dateStr) {
            // Format: DD.MM.YYYY
            const match = dateStr.match(/(\d{2})\.(\d{2})\.(\d{4})/);
            if (!match) return null;
            
            // Create date as UTC midnight to avoid timezone shifts
            // new Date(Y, M-1, D) creates local time.
            // If local time is behind UTC (e.g. GMT-5), converting to string/ordinal might shift day.
            
            // But here we use custom ordinal logic based on msPerDay.
            // Let's ensure we work with "No Timezone" logic by using UTC methods or setting time to noon.
            
            // Safer: Set hour to 12:00 to avoid DST shifts affecting "midnight" logic
            return new Date(match[3], match[2] - 1, match[1], 12, 0, 0); 
        }

        // Anchor date: Monday, Jan 5, 1970
        const ANCHOR_DATE = new Date(1970, 0, 5, 12, 0, 0); 
        const MS_PER_DAY = 24 * 60 * 60 * 1000;

        function toOrdinal(date) {
            // Calculate business days since anchor
            const diffTime = date.getTime() - ANCHOR_DATE.getTime();
            // Use round() instead of floor() to handle DST shifts (23h/25h days) safely
            const totalDays = Math.round(diffTime / MS_PER_DAY);
            
            const weeks = Math.floor(totalDays / 7);
            const days = totalDays % 7; // 0=Mon, ..., 4=Fri, 5=Sat, 6=Sun
            
            // Clamp Sat/Sun to 5 (start of next week / end of current week overlap)
            // But simpler: just count 5 days per week.
            // Mon(0)->0, Fri(4)->4, Sat(5)->5, Sun(6)->5, Mon(7)->5 (Wait, next Mon is 5)
            
            // Let's handle the case where totalDays might be negative (before 1970) just in case, 
            // though unlikely for this dataset. Assuming post-1970.
            
            return weeks * 5 + Math.min(days, 5);
        }

        function fromOrdinal(ordinal) {
            // Convert business days back to calendar date
            const weeks = Math.floor(ordinal / 5);
            const days = ordinal % 5; // 0..4.999
            
            // 5 business days -> 7 calendar days
            const totalDays = weeks * 7 + days;
            
            return new Date(ANCHOR_DATE.getTime() + totalDays * MS_PER_DAY);
        }

        // --- Regression Logic ---

        function weightedLinearRegression(x, y, weights) {
            const n = x.length;
            let sumW = 0;
            let sumWX = 0;
            let sumWY = 0;
            let sumWXX = 0;
            let sumWXY = 0;

            for (let i = 0; i < n; i++) {
                const w = weights[i];
                sumW += w;
                sumWX += w * x[i];
                sumWY += w * y[i];
                sumWXX += w * x[i] * x[i];
                sumWXY += w * x[i] * y[i];
            }

            const denom = sumW * sumWXX - sumWX * sumWX;
            if (denom === 0) return { slope: 0, intercept: 0 };

            const slope = (sumW * sumWXY - sumWX * sumWY) / denom;
            const intercept = (sumWY - slope * sumWX) / sumW;

            return { slope, intercept };
        }

        // --- Data Processing & Charting ---

        Promise.all([
            fetchAndParse(STATS_URL),
            fetchAndParse(HISTORICAL_DATA_URL)
        ]).then(([statsData, historicalData]) => {
            document.getElementById('loading').style.display = 'none';
            try {
                processAndRender(statsData, historicalData);
            } catch (e) {
                console.error(e);
                document.getElementById('error').textContent = "Error: " + e.message;
            }
        }).catch(err => {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('error').textContent = "Failed to load data: " + err.message;
        });

        function processAndRender(data, historicalData) {
            let globalMaxId = 0;
            const preBookedData = [];

            historicalData.forEach(row => {
                const idStr = String(row['ID'] || '').trim();
                const dateStr = String(row['–î–∞—Ç–∞'] || '').trim();
                
                if (!/^\d+$/.test(idStr)) return; 
                
                const id = parseInt(idStr, 10);
                if (isNaN(id)) return;

                if (id > globalMaxId) globalMaxId = id;

                const date = parseDate(dateStr);
                if (date) {
                    preBookedData.push({ id: id, date: date });
                }
            });
            
            // If globalMaxId is suspiciously high (like 48000), we might have parsed a phone number or bad data?
            // User said "actual max is around 5100, not 48k". 
            // Let's add a sanity filter: ID must be < 20000? 
            // Or just trust the regex ^\d+$ which excludes "48k".
            // The issue might have been row index confusion or a stray value.
            // With /^\d+$/ check, we should be safer.
            
            // Add buffer (100)
            const targetEndId = globalMaxId > 0 ? globalMaxId + 100 : 5500;

            // 1. Parse & Filter Data (Historical)
            const validData = [];
            const histRanges = []; // Store ranges [min, max] per date for visualization
            let maxId = 0;
            let maxDateOrdinal = 0;

            data.forEach(row => {
                const dateStr = row['–î–∞—Ç–∞ –ø—Ä–∏–π–æ–º—É'];
                const maxIdStr = row['–û—Å—Ç–∞–Ω–Ω—ñ–π –Ω–æ–º–µ—Ä —â–æ –∑–∞–π—à–æ–≤'];
                const minIdStr = row['–ü–µ—Ä—à–∏–π –Ω–æ–º–µ—Ä —â–æ –∑–∞–π—à–æ–≤'];
                const enteredCountStr = row['–ó–∞–π—à–æ–≤'];

                // Both columns are required
                if (!dateStr || !maxIdStr || !minIdStr) return;

                const date = parseDate(dateStr);
                if (!date) return;
                
                const ordinal = toOrdinal(date);
                
                let maxVal = NaN;
                let minVal = NaN;

                // Parse entered count early for weighting
                let enteredCount = 0;
                if (enteredCountStr) {
                    enteredCount = parseInt(enteredCountStr.replace(/\D/g, ''), 10);
                }
                if (isNaN(enteredCount) || enteredCount <= 0) enteredCount = 1;

                // Process Max ID
                maxVal = parseInt(maxIdStr.replace(/\D/g, ''));
                if (!isNaN(maxVal)) {
                    validData.push({ id: maxVal, date, ordinal, count: enteredCount });
                    if (maxVal > maxId) maxId = maxVal;
                }

                // Process Min ID
                minVal = parseInt(minIdStr.replace(/\D/g, ''));
                if (!isNaN(minVal)) {
                    validData.push({ id: minVal, date, ordinal, count: enteredCount });
                }

                // Store Range for Visualization if both exist
                if (!isNaN(maxVal) && !isNaN(minVal)) {
                    histRanges.push({
                        x: date,
                        y: [minVal, maxVal], // Chart.js bar chart range format
                        thickness: enteredCount // Raw count, will scale in chart options
                    });
                }

                if (ordinal > maxDateOrdinal) maxDateOrdinal = ordinal;
            });

            validData.sort((a, b) => a.ordinal - b.ordinal);

            if (validData.length === 0) throw new Error("–î—ñ–π—Å–Ω–∏—Ö –¥–∞–Ω–∏—Ö –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ.");

            // Filter Pre-booked Data outliers (> 3 months from last historical date)
            const lastHistoricalDateOrdinal = validData[validData.length - 1].ordinal;
            // 3 months is approx 65 business days (21.6 working days/month * 3)
            const cutoffOrdinal = lastHistoricalDateOrdinal + 65; 
            
            // Filter in place or create new array
            // We need to filter preBookedData which was passed in
            // However, preBookedData is an array of objects {id, date} (JS Date objects)
            
            // Let's convert cutoff to JS Date timestamp comparison for simplicity or re-calculate ordinal
            // The ordinal helper is simple: day count.
            
            const filteredPreBookedData = preBookedData.filter(d => {
                const ord = toOrdinal(d.date);
                // Filter if date is way too far in future (outlier)
                // e.g. > 3 months from last known processed date
                return ord <= cutoffOrdinal;
            });

            const dailyGroups = new Map();
            validData.forEach(d => {
                if (!dailyGroups.has(d.ordinal)) {
                    dailyGroups.set(d.ordinal, { ids: [], count: d.count });
                }
                dailyGroups.get(d.ordinal).ids.push(d.id);
            });

            const regressionData = Array.from(dailyGroups.entries()).map(([ord, data]) => {
                // Use average ID for the day for regression
                const avgId = data.ids.reduce((a, b) => a + b, 0) / data.ids.length;
                return { ordinal: ord, id: avgId, count: data.count };
            });

            // Ensure sorted (Map preserves insertion order from sorted validData, but explicit is safer)
            regressionData.sort((a, b) => a.ordinal - b.ordinal);

            const X = regressionData.map(d => d.id); // Predictor: Queue ID
            const Y = regressionData.map(d => d.ordinal); // Target: Date
            const n = regressionData.length;

            // Weights: Exponential decay e^(-3) -> e^0
            const weights = [];
            for (let i = 0; i < n; i++) {
                const val = -3 + (i / (n - 1)) * 3;
                weights.push(Math.exp(val));
            }

            // 3. Train Model
            const model = weightedLinearRegression(X, Y, weights);

            // 4. Calculate Statistics for Intervals
            let sumW = 0;
            let weightedMeanX = 0;
            for(let i=0; i<n; i++) {
                sumW += weights[i];
                weightedMeanX += weights[i] * X[i];
            }
            weightedMeanX /= sumW;

            let weightedVarX = 0;
            let weightedSumResSq = 0;
            for(let i=0; i<n; i++) {
                weightedVarX += weights[i] * Math.pow(X[i] - weightedMeanX, 2);
                const yPred = model.slope * X[i] + model.intercept;
                const res = Y[i] - yPred;
                weightedSumResSq += weights[i] * res * res;
            }

            const degreesOfFreedom = sumW - 2;
            const mseWeighted = weightedSumResSq / degreesOfFreedom;

            // T-scores
            // For "5% Chance" and "95% Chance" labels, we need the 5th and 95th percentiles.
            // This corresponds to a 90% Confidence Interval (alpha=0.10, two-tailed -> 0.05 in each tail).
            // inv(0.95) gives the 95th percentile.
            const tScore90 = jStat.studentt.inv(0.95, degreesOfFreedom);
            // 50% confidence -> alpha=0.50, two-tailed -> 0.75 (75th percentile)
            const tScore50 = jStat.studentt.inv(0.75, degreesOfFreedom);

            // 5. Generate Prediction Data Points
            // We want to plot Queue ID on Y axis, Date on X axis.
            // Chart.js Scatter: x=Date, y=ID
            
            const startId = maxId;
            const endId = targetEndId; 
            const minFeasibleOrdinal = maxDateOrdinal + 1; // Next day after last history

            // We generate dense points for the prediction lines
            const predPoints = [];
            
            // Use step of 1 for maximum vertical resolution
            for (let qId = startId; qId <= endId; qId += 1) {
                let predOrd = model.slope * qId + model.intercept;
                
                // Standard Error
                const term3 = Math.pow(qId - weightedMeanX, 2) / weightedVarX;
                const sePred = Math.sqrt(mseWeighted * (1 + 1/sumW + term3));

                const margin90 = tScore90 * sePred;
                const margin50 = tScore50 * sePred;

                let l90 = predOrd - margin90;
                let h90 = predOrd + margin90;
                let l50 = predOrd - margin50;
                let h50 = predOrd + margin50;

                // Logic Clamp: Future predictions cannot be in the past
                if (qId > maxId) {
                    if (predOrd < minFeasibleOrdinal) predOrd = minFeasibleOrdinal;
                    if (l90 < minFeasibleOrdinal) l90 = minFeasibleOrdinal;
                    if (l50 < minFeasibleOrdinal) l50 = minFeasibleOrdinal;
                }

                // Sort bounds
                if (l90 > predOrd) l90 = predOrd;
                if (h90 < predOrd) h90 = predOrd;
                if (l50 > predOrd) l50 = predOrd;
                if (h50 < predOrd) h50 = predOrd;

                predPoints.push({
                    id: qId,
                    mean: fromOrdinal(predOrd),
                    l90: fromOrdinal(l90), // 5th percentile
                    h90: fromOrdinal(h90), // 95th percentile
                    l50: fromOrdinal(l50),
                    h50: fromOrdinal(h50)
                });
            }

            // 6. Chart.js Data Structure
            
            // Historical Points
            const histData = validData.map(d => ({ x: d.date, y: d.id }));
            
            // Determine last historical date for filtering
            const lastHistoricalDate = validData[validData.length - 1].date;
            const lastHistoricalTime = lastHistoricalDate.getTime();

            // Pre-booked Points (From second sheet, filtered)
            const preBookedChartData = filteredPreBookedData.map(d => ({ x: d.date, y: d.id }));

            // Helper to filter out points in the past (relative to history)
            const filterFuture = (arr) => arr.filter(p => p.x.getTime() >= lastHistoricalTime);

            // Mean Line
            const meanData = filterFuture(predPoints.map(p => ({ x: p.mean, y: p.id })));
            
            // Confidence Intervals
            // We filter them to ensure they don't show "past" predictions
            
            const l90Data = filterFuture(predPoints.map(p => ({ x: p.l90, y: p.id })));
            const h90Data = filterFuture(predPoints.map(p => ({ x: p.h90, y: p.id })));
            const l50Data = filterFuture(predPoints.map(p => ({ x: p.l50, y: p.id })));
            const h50Data = filterFuture(predPoints.map(p => ({ x: p.h50, y: p.id })));

            renderChart(histData, histRanges, preBookedChartData, meanData, l90Data, h90Data, l50Data, h50Data);
        }

        function renderChart(histData, histRanges, preBookedData, meanData, l90Data, h90Data, l50Data, h50Data) {
            const ctx = document.getElementById('queueChart').getContext('2d');
            
            // Custom Plugin for Variable Width Lines
            const variableWidthLinePlugin = {
                id: 'variableWidthLine',
                beforeDatasetsDraw(chart, args, options) {
                    const { ctx, scales: { x, y } } = chart;
                    const ranges = options.data || [];

                    ctx.save();
                    ctx.lineCap = 'butt';
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';

                    ranges.forEach(range => {
                        if (!range.x || !range.y) return;

                        const xPos = x.getPixelForValue(range.x.getTime());
                        const yMin = y.getPixelForValue(range.y[0]);
                        const yMax = y.getPixelForValue(range.y[1]);
                        
                        // Calculate thickness
                        // Scale: 0.2px per person, clamped between 2px and 30px
                        const thickness = Math.max(2, Math.min(range.thickness * 0.2, 30));
                        
                        ctx.lineWidth = thickness;
                        
                        ctx.beginPath();
                        ctx.moveTo(xPos, yMin);
                        ctx.lineTo(xPos, yMax);
                        ctx.stroke();
                    });

                    ctx.restore();
                }
            };

            // Helper to freeze chart at a specific ID
            // Defined here to access the data arrays via closure
            const freezeAtId = (chart, targetId) => {
                // Find nearest point in meanData
                const nearest = meanData.reduce((prev, curr) => 
                    Math.abs(curr.y - targetId) < Math.abs(prev.y - targetId) ? curr : prev
                );
                
                // Find matching bounds index
                const idx = meanData.indexOf(nearest);
                
                // Check if this ID exists in Historical or Pre-booked data
                let actualDate = null;
                let actualType = null; // 'Historical' or 'Pre-booked'
                
                // Check Historical
                const histMatch = histData.find(d => d.y === targetId);
                if (histMatch) {
                    actualDate = histMatch.x;
                    actualType = '–Ü—Å—Ç–æ—Ä–∏—á–Ω–∞ –¥–∞—Ç–∞';
                } else {
                    // Check Pre-booked
                    const preBookedMatch = preBookedData.find(d => d.y === targetId);
                    if (preBookedMatch) {
                        actualDate = preBookedMatch.x;
                        actualType = '–ó–∞–ø–∏—Å –Ω–∞';
                    }
                }
                
                if (idx !== -1) {
                    chart.frozen = true;
                    chart.options.plugins.tooltip.enabled = false;
                    
                    chart.frozenData = {
                        id: nearest.y,
                        mean: nearest.x,
                        l90: l90Data[idx].x,
                        h90: h90Data[idx].x,
                        l50: l50Data[idx].x,
                        h50: h50Data[idx].x,
                        actualDate: actualDate,
                        actualType: actualType
                    };

                    // Update URL
                    if (window.history.replaceState) {
                        const url = new URL(window.location);
                        url.searchParams.set('id', targetId);
                        window.history.replaceState({}, '', url);
                    }

                    chart.update();
                }
            };

            const freezePlugin = {
                id: 'freezeTooltip',
                defaults: {
                    frozen: false,
                    frozenX: null,
                    frozenY: null,
                    frozenData: null
                },
                afterInit: (chart) => {
                    chart.frozen = false;
                    
                    // Track drag state to prevent click triggering on drag
                    let startX = 0;
                    let startY = 0;
                    
                    chart.canvas.addEventListener('pointerdown', (e) => {
                        startX = e.clientX;
                        startY = e.clientY;
                    });

                    // Bind external input controls
                    const input = document.getElementById('queueInput');
                    const btn = document.getElementById('findBtn');
                    
                    const handleSearch = () => {
                        const val = parseInt(input.value, 10);
                        if (!isNaN(val)) {
                            freezeAtId(chart, val);
                        }
                    };
                    
                    document.getElementById('resetZoomBtn').addEventListener('click', () => {
                        chart.resetZoom();
                    });

                    btn.addEventListener('click', handleSearch);
                    input.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') handleSearch();
                    });

                    // Check URL for ID param on load
                    const urlParams = new URLSearchParams(window.location.search);
                    const idParam = urlParams.get('id');
                    if (idParam) {
                        const val = parseInt(idParam, 10);
                        if (!isNaN(val)) {
                            input.value = val;
                            // Use setTimeout to ensure chart is ready
                            setTimeout(() => freezeAtId(chart, val), 0);
                        }
                    }
                    
                    // Handle click to freeze/unfreeze
                    chart.canvas.addEventListener('click', (e) => {
                        // Check distance
                        const dist = Math.hypot(e.clientX - startX, e.clientY - startY);
                        if (dist > 10) return; // Ignore drags > 10px

                        if (chart.frozen) {
                            // Unfreeze
                            chart.frozen = false;
                            chart.options.plugins.tooltip.enabled = true; // Re-enable native
                            
                            // Clear URL param
                            if (window.history.replaceState) {
                                const url = new URL(window.location);
                                url.searchParams.delete('id');
                                window.history.replaceState({}, '', url);
                            }
                            
                            // Remove custom guides
                            // We handle drawing in afterDraw, so just forcing update clears them
                            chart.update();
                        } else {
                            // Freeze
                            // Get data under cursor
                            const points = chart.getElementsAtEventForMode(e, 'nearest', { intersect: false, axis: 'y' }, true);
                            
                            if (points.length) {
                                // Use the click Y value to find target
                                const yValue = chart.scales.y.getValueForPixel(e.offsetY);
                                const targetY = Math.round(yValue);
                                
                                freezeAtId(chart, targetY);
                            }
                        }
                    });
                },
                afterDraw: (chart) => {
                    if (chart.frozen && chart.frozenData) {
                        const ctx = chart.ctx;
                        const data = chart.frozenData;
                        
                        // Get Pixels
                        const yPix = chart.scales.y.getPixelForValue(data.id);
                        const xPixMean = chart.scales.x.getPixelForValue(data.mean.getTime());
                        
                        // Draw Guides
                        ctx.save();
                        ctx.beginPath();
                        ctx.strokeStyle = 'gray';
                        ctx.setLineDash([5, 5]);
                        ctx.lineWidth = 1;
                        
                        // Horizontal Line
                        ctx.moveTo(chart.chartArea.left, yPix);
                        ctx.lineTo(chart.chartArea.right, yPix);
                        
                        // Vertical Line at Mean
                        ctx.moveTo(xPixMean, chart.chartArea.top);
                        ctx.lineTo(xPixMean, chart.chartArea.bottom);
                        
                        // If Actual Data exists, draw Vertical Line at Actual Date
                        if (data.actualDate) {
                            const xPixActual = chart.scales.x.getPixelForValue(data.actualDate.getTime());
                            
                            // Move to actual date
                            ctx.moveTo(xPixActual, chart.chartArea.top);
                            ctx.lineTo(xPixActual, chart.chartArea.bottom);
                            
                            // Highlight the point intersection (optional circle)
                            // ctx.moveTo(xPixActual + 3, yPix);
                            // ctx.arc(xPixActual, yPix, 3, 0, 2 * Math.PI);
                        }
                        
                        ctx.stroke();
                        
                        // Draw Tooltip Box
                        const formatDate = (d) => d.toISOString().split('T')[0];
                        
                        const textLines = [
                            `–ù–æ–º–µ—Ä —É —á–µ—Ä–∑—ñ: ${data.id}`,
                            `5% —à–∞–Ω—Å—É: ${formatDate(data.l90)}`,
                            `25% —à–∞–Ω—Å—É: ${formatDate(data.l50)}`,
                            `50% —à–∞–Ω—Å—É: ${formatDate(data.mean)}`,
                            `75% —à–∞–Ω—Å—É: ${formatDate(data.h50)}`,
                            `95% —à–∞–Ω—Å—É: ${formatDate(data.h90)}`
                        ];
                        
                        // Add actual date info if available
                        if (data.actualDate) {
                            textLines.unshift(`${data.actualType}: ${formatDate(data.actualDate)}`);
                        } else {
                            textLines.unshift('–ù–µ–º–∞—î –∑–∞–ø–∏—Å—É!');
                        }
                        
                        // Position box fixed at Top-Left of the chart area
                        // This avoids obscuring recent data (usually at bottom-right or top-right)
                        const padding = 10;
                        const lineHeight = 20;
                        const boxWidth = 220; 
                        const boxHeight = textLines.length * lineHeight + padding * 2;
                        
                        // Fixed position: Top-Left corner of the chart area with a small margin
                        let boxX = chart.chartArea.left + 20; 
                        let boxY = chart.chartArea.top + 20;
                        
                        // Background
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.95)'; // Slightly more opaque for readability
                        ctx.strokeStyle = 'black';
                        ctx.setLineDash([]);
                        ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
                        ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);
                        
                        // Text
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'middle';
                        
                        textLines.forEach((line, i) => {
                            // 0: Status (Actual Date or "–ù–µ–º–∞—î –∑–∞–ø–∏—Å—É!")
                            // 1: Queue ID
                            // 4: Mean (50%)
                            let isBold = (i === 0 || i === 1 || i === 4);
                            
                            ctx.font = isBold ? 'bold 12px sans-serif' : '12px sans-serif';
                            
                            if (!data.actualDate && i === 0) {
                                ctx.fillStyle = 'red';
                            } else {
                                ctx.fillStyle = 'black';
                            }
                            
                            ctx.fillText(line, boxX + padding, boxY + padding + i * lineHeight + lineHeight/2);
                        });
                        
                        ctx.restore();
                    }
                }
            };

            // Register custom tooltip positioner
            Chart.Tooltip.positioners.topLeft = function(elements, eventPosition) {
                const chart = this.chart;
                return {
                    x: chart.chartArea.left + 20,
                    y: chart.chartArea.top + 20
                };
            };

            new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [
                        {
                            label: '–Ü—Å—Ç–æ—Ä–∏—á–Ω—ñ –¥–∞–Ω—ñ',
                            data: histData,
                            backgroundColor: 'rgba(0, 0, 0, 0.6)',
                            pointRadius: 3,
                            order: 1
                        },
                        {
                            label: '–ü–æ–ø–µ—Ä–µ–¥–Ω—å–æ –∑–∞–ø–∏—Å–∞–Ω—ñ',
                            data: preBookedData,
                            backgroundColor: 'rgba(255, 165, 0, 0.8)', // Solid Orange
                            borderColor: 'rgba(255, 140, 0, 1)',
                            borderWidth: 1,
                            pointRadius: 4,
                            pointStyle: 'rectRot', 
                            order: 0 // Topmost layer
                        },
                        {
                            label: '95% –®–∞–Ω—Å',
                            data: h90Data,
                            borderColor: 'rgb(0, 255, 0)', // Bright Green
                            borderWidth: 2,
                            showLine: true,
                            pointRadius: 0, // Hide points for lines
                        },
                        {
                            label: '75% –®–∞–Ω—Å',
                            data: h50Data,
                            borderColor: 'rgba(0, 128, 0, 0.5)', // Dim Green
                            borderWidth: 2,
                            showLine: true,
                            pointRadius: 0, // Hide points for lines
                        },
                        {
                            label: '–ü—Ä–æ–≥–Ω–æ–∑ (50% –®–∞–Ω—Å)',
                            data: meanData,
                            borderColor: 'blue',
                            borderWidth: 2,
                            showLine: true,
                            pointRadius: 0, // Hide points for lines
                        },
                        {
                            label: '25% –®–∞–Ω—Å',
                            data: l50Data,
                            borderColor: 'rgba(139, 0, 0, 0.5)', // Dim Red
                            borderWidth: 2,
                            showLine: true,
                            pointRadius: 0, // Hide points for lines
                        },
                        {
                            label: '5% –®–∞–Ω—Å',
                            data: l90Data,
                            borderColor: 'red', // Red
                            borderWidth: 2,
                            showLine: true,
                            pointRadius: 0, // Hide points for lines
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'week',
                                displayFormats: { week: 'yyyy-MM-dd' }
                            },
                            adapters: { 
                                date: {
                                    locale: window.dateFns ? window.dateFns.locale.uk : undefined
                                }
                            },
                            title: { display: true, text: '–î–∞—Ç–∞' }
                        },
                        y: {
                            title: { display: true, text: '–ù–æ–º–µ—Ä —É —á–µ—Ä–∑—ñ' }
                        }
                    },
                    plugins: {
                        variableWidthLine: {
                            data: histRanges
                        },
                        legend: {
                            // Only show Hist and Mean
                            labels: {
                                filter: function(item, chart) {
                                    // Hide if hidden property is true (which we set for CI)
                                    // Logic: item.hidden is true if user clicked to hide it. 
                                    // But we set 'hidden: true' in dataset config.
                                    // Chart.js default filter shows all unless we override.
                                    
                                    // We want to hide datasets 2,3,4,5 (indices) from legend
                                    // Or check label text
                                    const text = item.text || '';
                                    return !text.includes('%'); 
                                }
                            }
                        },
                        zoom: {
                            pan: {
                                enabled: true,
                                mode: 'xy',
                                threshold: 10,
                            },
                            zoom: {
                                wheel: {
                                    enabled: true,
                                    speed: 0.05, // Default is 0.1, lowering to make it less sensitive
                                },
                                pinch: {
                                    enabled: true
                                },
                                mode: 'xy',
                            }
                        },
                        tooltip: {
                            position: 'topLeft', // Use our custom positioner
                            mode: 'nearest',
                            axis: 'y',
                            intersect: false,
                            callbacks: {
                                title: function(context) {
                                    // Show Queue ID in the tooltip title
                                    if (context.length > 0) {
                                        return `–ù–æ–º–µ—Ä —É —á–µ—Ä–∑—ñ: ${context[0].parsed.y}`;
                                    }
                                    return '';
                                },
                                label: function(context) {
                                    // Custom tooltip formatting if needed
                                    if (context.dataset.label === '–Ü—Å—Ç–æ—Ä–∏—á–Ω—ñ –¥–∞–Ω—ñ') {
                                        return `ID: ${context.raw.y}, –î–∞—Ç–∞: ${context.raw.x.toISOString().split('T')[0]}`;
                                    }
                                    // Use YYYY-MM-DD format
                                    return `${context.dataset.label}: ${context.raw.x.toISOString().split('T')[0]}`;
                                }
                            }
                        },
                        freezeTooltip: true // Activate our custom plugin
                    },
                    interaction: {
                        mode: 'nearest',
                        axis: 'y',
                        intersect: false
                    }
                },
                plugins: [{
                    id: 'cursorLine',
                    afterDraw: (chart) => {
                        if (chart.tooltip?._active?.length) {
                            const activePoint = chart.tooltip._active[0];
                            const ctx = chart.ctx;
                            const y = activePoint.element.y;
                            const left = chart.chartArea.left;
                            const right = chart.chartArea.right;

                            ctx.save();
                            ctx.beginPath();
                            ctx.moveTo(left, y);
                            ctx.lineTo(right, y);
                            ctx.lineWidth = 1;
                            ctx.strokeStyle = 'red';
                            ctx.stroke();
                            ctx.restore();
                        }
                    }
                }, freezePlugin, variableWidthLinePlugin]
            });
        }
    </script>
</body>
</html>
