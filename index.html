<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ü—Ä–æ–≥–Ω–æ–∑ —á–µ—Ä–≥–∏ –í–õ–ö</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jstat/1.9.6/jstat.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chartjs-plugin-zoom/2.0.1/chartjs-plugin-zoom.min.js"></script>
    <style>
        body { font-family: sans-serif; margin: 20px; }
        #loading { font-style: italic; color: #666; }
        #chart-container { position: relative; height: 80vh; width: 100%; }
        .error { color: red; font-weight: bold; }
        .header-container { display: flex; align-items: center; gap: 15px; }
        .header-icon { width: 48px; height: 48px; }
    </style>
</head>
<body>
    <div class="header-container">
        <img src="favicon.ico" alt="–í–õ–ö" class="header-icon">
        <h1>–ü—Ä–æ–≥–Ω–æ–∑ —á–µ—Ä–≥–∏ –í–õ–ö –Ω–∞ –ó–∞–∫—Ä–µ–≤—Å—å–∫–æ–≥–æ 81/1</h1>
    </div>
    <div id="info-container" style="display: flex; flex-wrap: wrap; gap: 15px; margin: 10px 0; align-items: baseline;">
        <div id="next-day-info" style="font-size: 1.1em; font-weight: bold; color: #2e7d32;"></div>
        <div id="stats-info" style="color: #666; font-size: 0.9em;"></div>
    </div>
    <div id="loading">–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –¥–∞–Ω–∏—Ö –∑ Google –¢–∞–±–ª–∏—Ü—ñ...</div>
    <div id="error" class="error"></div>
    
    <div style="margin-bottom: 10px; display: flex; align-items: center; gap: 10px;">
        <input type="text" id="queueInput" placeholder="–ù–æ–º–µ—Ä —á–µ—Ä–≥–∏" style="padding: 5px; width: 150px;">
        <button id="findBtn" style="padding: 5px 10px; cursor: pointer;">–ü–æ–∫–∞–∑–∞—Ç–∏ –ø—Ä–æ–≥–Ω–æ–∑</button>
        <button id="resetZoomBtn" style="padding: 5px 10px; cursor: pointer;">–°–∫–∏–Ω—É—Ç–∏ –∑—É–º</button>
        <span style="margin-left: auto; color: #555; font-style: italic;">üëâ –ù–∞—Ç–∏—Å–Ω—ñ—Ç—å –Ω–∞ –≥—Ä–∞—Ñ—ñ–∫ —â–æ–± –ø–æ–±–∞—á–∏—Ç–∏ –π–º–æ–≤—ñ—Ä–Ω–æ—Å—Ç—ñ –ø–æ—á–∞—Ç–∫—É –í–õ–ö</span>
    </div>

    <div id="chart-container">
        <canvas id="queueChart"></canvas>
    </div>
    
    <div style="margin-top: 10px; font-style: italic; color: #666; font-size: 0.9em;">
        <strong>–ü—Ä–∏–º—ñ—Ç–∫–∏:</strong><br>
        ‚Ä¢ –ü–æ–ø–µ—Ä–µ–¥–Ω—ñ –∑–∞–ø–∏—Å–∏ –Ω–∞ –¥–∞—Ç–∏ > 3 –º—ñ—Å—è—Ü—ñ–≤ –≤—ñ–¥ –æ—Å—Ç–∞–Ω–Ω—å–æ—ó —ñ—Å—Ç–æ—Ä–∏—á–Ω–æ—ó –¥–∞—Ç–∏ –Ω–µ –≤—ñ–¥–æ–±—Ä–∞–∂–∞—é—Ç—å—Å—è
    </div>

    <script type="module">
        import { parse } from 'https://cdn.jsdelivr.net/npm/csv-parse@5.5.3/+esm';
        
        // Google Sheet CSV URL for pre-booked data
        const SHEET_ID = '1d9OG-0b7wxxqrOujC9v6ikhjMKL2ei3wfrfaG61zSjA';
        const PRE_BOOKED_SHEET_ID = '84071606';
        
        const preBookedDataUrl = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/export?format=csv&gid=${PRE_BOOKED_SHEET_ID}`;

        const isLocalhost = window.location.hostname === 'localhost' || 
                            window.location.hostname === '127.0.0.1' ||
                            window.location.protocol === 'file:';

        // Attendance data from daily sheets
        const ATTENDANCE_DATA_URL = 'attendance_data.json';
        
        const PRE_BOOKED_PROXY_URL = isLocalhost 
            ? 'https://corsproxy.io/?' + encodeURIComponent(preBookedDataUrl) 
            : preBookedDataUrl;

        let migratedDataUrl = null;

        // --- –ö–æ–Ω—Å—Ç–∞–Ω—Ç–∏ –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –ø—Ä–æ–≥–Ω–æ–∑–Ω–æ—ó –º–æ–¥–µ–ª—ñ ---
        const WEIGHT_EXP_MIN = -3;  // –ú—ñ–Ω—ñ–º–∞–ª—å–Ω–∞ –µ–∫—Å–ø–æ–Ω–µ–Ω—Ç–∞ –≤–∞–≥–∏ (–¥–ª—è –Ω–∞–π—Å—Ç–∞—Ä—ñ—à–∏—Ö —Ç–æ—á–æ–∫)
        const WEIGHT_EXP_MAX = 1;   // –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞ –µ–∫—Å–ø–æ–Ω–µ–Ω—Ç–∞ –≤–∞–≥–∏ (–¥–ª—è –Ω–∞–π–Ω–æ–≤—ñ—à–∏—Ö —Ç–æ—á–æ–∫)
        const LIVE_QUEUE_WEIGHT = 0; // –í–∞–≥–∞ –¥–ª—è –∂–∏–≤–æ—ó —á–µ—Ä–≥–∏ (0 = –≤–∏–∫–ª—é—á–∏—Ç–∏ –∑ —Ä–æ–∑—Ä–∞—Ö—É–Ω–∫—ñ–≤)

        // --- Helper Functions ---

        function idToNumeric(idVal) {
            // Converts ID string to numeric value for regression
            // "1234" -> 1234.0
            // "1234/1" -> 1234.01
            // "1234/2" -> 1234.02
            const s = String(idVal).trim();
            if (!s) return null;
            
            if (s.includes('/')) {
                const parts = s.split('/');
                const main = parseInt(parts[0], 10);
                if (isNaN(main)) return null;
                
                let sub = 0;
                if (parts.length > 1) {
                    const subNum = parseInt(parts[1], 10);
                    if (!isNaN(subNum)) {
                        sub = subNum;
                    }
                }
                return main + (sub / 100.0);
            }
            
            // Try parsing as plain number
            const num = parseFloat(s);
            if (!isNaN(num)) return num;
            
            // Fallback: extract first sequence of digits
            const match = s.match(/^(\d+)/);
            if (match) {
                return parseFloat(match[1]);
            }
            
            return null;
        }

        function numericToId(numericVal) {
            // Converts numeric value back to ID string (INVERSE of idToNumeric)
            // 1234.0 -> "1234"
            // 1234.01 -> "1234/1"
            // 1234.04 -> "1234/4"
            const main = Math.floor(numericVal);
            const fractional = numericVal - main;
            
            // Use tighter tolerance for detecting "whole" numbers
            if (Math.abs(fractional) < 0.001) {
                return String(main);
            }
            
            const sub = Math.round(fractional * 100);
            
            // Debug logging for problematic IDs
            if (main === 4794 && sub > 0) {
                console.log('numericToId DEBUG:', { numericVal, main, fractional, sub, result: `${main}/${sub}` });
            }
            
            if (sub > 0) {
                return `${main}/${sub}`;
            }
            
            return String(main);
        }

        function parseDate(dateStr) {
            // Format: DD.MM.YYYY
            const match = dateStr.match(/(\d{2})\.(\d{2})\.(\d{4})/);
            if (!match) return null;
            
            // Create date as UTC midnight to avoid timezone shifts
            // new Date(Y, M-1, D) creates local time.
            // If local time is behind UTC (e.g. GMT-5), converting to string/ordinal might shift day.
            
            // But here we use custom ordinal logic based on msPerDay.
            // Let's ensure we work with "No Timezone" logic by using UTC methods or setting time to noon.
            
            // Safer: Set hour to 12:00 to avoid DST shifts affecting "midnight" logic
            return new Date(match[3], match[2] - 1, match[1], 12, 0, 0); 
        }

        async function fetchMigratedData(attendanceData, earliestPreBookedDate) {
            if (!earliestPreBookedDate) {
                if (!attendanceData || !attendanceData.attendance_points || attendanceData.attendance_points.length === 0) {
                    return { migratedIds: [], currentDate: null };
                }

                const dates = attendanceData.attendance_points.map(p => p.date);
                dates.sort();
                const latestDate = dates[dates.length - 1];
                earliestPreBookedDate = new Date(latestDate + 'T12:00:00');
            }
            
            const csvDate = earliestPreBookedDate.toISOString().split('T')[0];
            const csvFileName = `daily_sheets_cache/${csvDate}.csv`;
            migratedDataUrl = csvFileName;
            
            try {
                const response = await fetch(csvFileName);
                if (!response.ok) {
                    console.error(`–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ CSV —Ñ–∞–π–ª: ${csvFileName} (—Å—Ç–∞—Ç—É—Å: ${response.status})`);
                    throw new Error(`CSV —Ñ–∞–π–ª ${csvFileName} –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ`);
                }
                const csvText = await response.text();
                
                const lines = csvText.split('\n');
                let currentDateParsed = null;
                
                for (let i = 0; i < Math.min(5, lines.length); i++) {
                    if (lines[i].includes('–ü–æ—Ç–æ—á–Ω–∏–π –ø—Ä–∏–π–æ–º')) {
                        const dateMatch = lines[i].match(/(\d{2}\.\d{2}\.\d{4})/);
                        if (dateMatch) {
                            currentDateParsed = parseDate(dateMatch[1]);
                        }
                        break;
                    }
                }
                
                const records = await new Promise((resolve, reject) => {
                    parse(csvText, { 
                        columns: false,
                        skip_empty_lines: true,
                        from_line: 4,
                        relax_column_count: true
                    }, (err, records) => {
                        if (err) {
                            console.error('CSV parse error:', err);
                            reject(err);
                        } else {
                            resolve(records);
                        }
                    });
                });
                
                if (!records || records.length === 0) {
                    console.error(`CSV —Ñ–∞–π–ª ${csvFileName} –ø–æ—Ä–æ–∂–Ω—ñ–π`);
                    return { migratedIds: [], currentDate: currentDateParsed };
                }
                
                const migratedIds = [];
                const ID_COLUMN_INDEX = 7;
                
                records.forEach(row => {
                    if (row.length > ID_COLUMN_INDEX) {
                        const idStr = String(row[ID_COLUMN_INDEX] || '').trim();
                        if (idStr && /^\d{4}(\/\d)?/.test(idStr)) {
                            migratedIds.push(idStr);
                        }
                    }
                });
                
                return { migratedIds, currentDate: currentDateParsed };
            } catch (err) {
                console.error('–ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –º—ñ–≥—Ä–∞—Ü—ñ–π–Ω–∏—Ö –¥–∞–Ω–∏—Ö:', err);
                return { migratedIds: [], currentDate: null };
            }
        }

        // Anchor date: Monday, Jan 5, 1970
        const ANCHOR_DATE = new Date(1970, 0, 5, 12, 0, 0); 
        const MS_PER_DAY = 24 * 60 * 60 * 1000;

        function toOrdinal(date) {
            // Calculate business days since anchor
            const diffTime = date.getTime() - ANCHOR_DATE.getTime();
            // Use round() instead of floor() to handle DST shifts (23h/25h days) safely
            const totalDays = Math.round(diffTime / MS_PER_DAY);
            
            const weeks = Math.floor(totalDays / 7);
            const days = totalDays % 7; // 0=Mon, ..., 4=Fri, 5=Sat, 6=Sun
            
            // Clamp Sat/Sun to 5 (start of next week / end of current week overlap)
            // But simpler: just count 5 days per week.
            // Mon(0)->0, Fri(4)->4, Sat(5)->5, Sun(6)->5, Mon(7)->5 (Wait, next Mon is 5)
            
            // Let's handle the case where totalDays might be negative (before 1970) just in case, 
            // though unlikely for this dataset. Assuming post-1970.
            
            return weeks * 5 + Math.min(days, 5);
        }

        function fromOrdinal(ordinal) {
            // Convert business days back to calendar date
            const weeks = Math.floor(ordinal / 5);
            const days = ordinal % 5; // 0..4.999
            
            // 5 business days -> 7 calendar days
            const totalDays = weeks * 7 + days;
            
            return new Date(ANCHOR_DATE.getTime() + totalDays * MS_PER_DAY);
        }

        // --- Regression Logic ---

        function weightedLinearRegression(x, y, weights) {
            const n = x.length;
            let sumW = 0;
            let sumWX = 0;
            let sumWY = 0;
            let sumWXX = 0;
            let sumWXY = 0;

            for (let i = 0; i < n; i++) {
                const w = weights[i];
                sumW += w;
                sumWX += w * x[i];
                sumWY += w * y[i];
                sumWXX += w * x[i] * x[i];
                sumWXY += w * x[i] * y[i];
            }

            const denom = sumW * sumWXX - sumWX * sumWX;
            if (denom === 0) return { slope: 0, intercept: 0 };

            const slope = (sumW * sumWXY - sumWX * sumWY) / denom;
            const intercept = (sumWY - slope * sumWX) / sumW;

            return { slope, intercept };
        }

        // --- Data Processing & Charting ---

        let chartInstance = null;

        let globalAttendanceData = null;
        let globalMigratedData = null;

        Promise.all([
            fetch(ATTENDANCE_DATA_URL).then(r => r.json()),
            fetch(PRE_BOOKED_PROXY_URL)
                .then(response => response.text())
                .then(csvText => {
                    return new Promise((resolve, reject) => {
                        parse(csvText, {
                            columns: true, 
                            skip_empty_lines: true, 
                            from_line: 3 
                        }, (err, records) => {
                            if (err) reject(err);
                            else resolve(records);
                        });
                    });
                })
        ])
        .then(([attendanceData, preBookedRecords]) => {
            globalAttendanceData = attendanceData;
            
            let earliestPreBookedDate = null;
            if (preBookedRecords && preBookedRecords.length > 0) {
                const dates = preBookedRecords
                    .map(row => parseDate(String(row['–î–∞—Ç–∞'] || '').trim()))
                    .filter(d => d !== null);
                
                if (dates.length > 0) {
                    dates.sort((a, b) => a - b);
                    earliestPreBookedDate = dates[0];
                }
            }
            
            document.getElementById('loading').textContent = '–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –º—ñ–≥—Ä–∞—Ü—ñ–π–Ω–∏—Ö –¥–∞–Ω–∏—Ö...';
            return fetchMigratedData(attendanceData, earliestPreBookedDate)
                .then(migratedData => ({ attendanceData, preBookedRecords, migratedData }));
        })
        .then(({ attendanceData, preBookedRecords, migratedData }) => {
            globalMigratedData = migratedData;
            document.getElementById('loading').style.display = 'none';
            
            try {
                chartInstance = processAndRender(attendanceData, preBookedRecords, migratedData);
            } catch (e) {
                console.error(e);
                document.getElementById('error').textContent = "Error: " + e.message;
            }
        })
        .catch(err => {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('error').textContent = "Failed to load data: " + err.message;
        });

        function processAndRender(attendanceData, preBookedRecords, migratedData) {
            console.log(`–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ ${attendanceData.total_points} —Ç–æ—á–æ–∫ –≤—ñ–¥–≤—ñ–¥—É–≤–∞–Ω–æ—Å—Ç—ñ`);
            
            let globalMaxId = 0;
            
            // –û–±—Ä–æ–±–∫–∞ –¥–∞–Ω–∏—Ö —Ñ–∞–∫—Ç–∏—á–Ω–æ—ó –≤—ñ–¥–≤—ñ–¥—É–≤–∞–Ω–æ—Å—Ç—ñ –∑ —â–æ–¥–µ–Ω–Ω–∏—Ö –∞—Ä–∫—É—à—ñ–≤
            const allAttendancePoints = [];
            const liveQueuePoints = [];
            const regularPoints = [];
            let maxId = 0;
            let maxDateOrdinal = 0;
            let minDateOrdinal = Infinity;
            
            // –ì—Ä—É–ø—É—î–º–æ –¥–∞–Ω—ñ –∑–∞ –¥–∞—Ç–∞–º–∏ –¥–ª—è –≤—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—ó –¥—ñ–∞–ø–∞–∑–æ–Ω—ñ–≤
            const dailyRanges = new Map();
            
            // –°—Ç–≤–æ—Ä—é—î–º–æ mapping: numeric ID -> original string ID
            const numericToOriginalId = new Map();
            
            attendanceData.attendance_points.forEach(point => {
                // String ID - first-class citizen
                const id = String(point.id);
                const idNumeric = idToNumeric(id);
                if (idNumeric === null || isNaN(idNumeric)) {
                    console.warn('–ü—Ä–æ–ø—É—â–µ–Ω–æ –Ω–µ–≤–∞–ª—ñ–¥–Ω–∏–π ID:', point.id);
                    return;
                }
                
                // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ mapping –¥–ª—è –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü—ñ—ó –Ω–∞–∑–∞–¥
                numericToOriginalId.set(idNumeric, id);
                
                const date = new Date(point.date + 'T12:00:00');
                const ordinal = toOrdinal(date);
                const isLive = point.is_live || false;
                
                const pointData = { id, idNumeric, date, ordinal, isLive };
                allAttendancePoints.push(pointData);
                
                // –î–ª—è chart plotting –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ numeric, –∞–ª–µ –∑–±–µ—Ä—ñ–≥–∞—î–º–æ string
                if (isLive) {
                    liveQueuePoints.push({ x: date, y: idNumeric, id });
                } else {
                    regularPoints.push({ x: date, y: idNumeric, id });
                }
                
                if (idNumeric > maxId) maxId = idNumeric;
                if (ordinal > maxDateOrdinal) maxDateOrdinal = ordinal;
                if (ordinal < minDateOrdinal) minDateOrdinal = ordinal;
                
                // –î–æ–¥–∞—î–º–æ –¥–æ –≥—Ä—É–ø–∏ –¥–ª—è –æ–±—á–∏—Å–ª–µ–Ω–Ω—è –¥—ñ–∞–ø–∞–∑–æ–Ω—É
                if (!dailyRanges.has(point.date)) {
                    dailyRanges.set(point.date, { ids: [], date: date });
                }
                dailyRanges.get(point.date).ids.push(idNumeric);
            });
            
            // –°—Ç–≤–æ—Ä—é—î–º–æ –¥—ñ–∞–ø–∞–∑–æ–Ω–∏ –¥–ª—è –≤—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—ó
            const histRanges = [];
            dailyRanges.forEach((data, dateStr) => {
                const ids = data.ids;
                if (ids.length > 0) {
                    histRanges.push({
                        x: data.date,
                        y: [Math.min(...ids), Math.max(...ids)],
                        thickness: ids.length
                    });
                }
            });
            
            const targetEndId = Math.max(globalMaxId, maxId) + 100;

            if (allAttendancePoints.length === 0) {
                console.error('No attendance points found!');
                throw new Error("–î—ñ–π—Å–Ω–∏—Ö –¥–∞–Ω–∏—Ö –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ.");
            }
            
            console.log('Attendance points loaded:', allAttendancePoints.length);

            // Calculate average daily count (last 10 working days)
            const dateCountMap = new Map();
            dailyRanges.forEach((data) => {
                const iso = data.date.toISOString().split('T')[0];
                dateCountMap.set(iso, data.ids.length);
            });

            const lastWorkingDate = fromOrdinal(maxDateOrdinal);
            const lastWorkingDays = [];
            let currentDate = new Date(lastWorkingDate);

            while (lastWorkingDays.length < 10) {
                const dayOfWeek = currentDate.getDay(); // 0=Sun, 6=Sat
                if (dayOfWeek !== 0 && dayOfWeek !== 6) {
                    const iso = currentDate.toISOString().split('T')[0];
                    const count = dateCountMap.get(iso) || 0;
                    lastWorkingDays.push({ date: new Date(currentDate), count });
                }
                currentDate.setDate(currentDate.getDate() - 1);
            }

            const total = lastWorkingDays.reduce((sum, item) => sum + item.count, 0.0);
            const avgDailyCount = (total / lastWorkingDays.length).toFixed(1);

            // –û–±—Ä–æ–±–∫–∞ preBooked —Ç–∞ migrated –¥–∞–Ω–∏—Ö
            const preBookedData = [];
            
            if (preBookedRecords) {
                preBookedRecords.forEach(row => {
                    const idStr = String(row['ID'] || '').trim();
                    const dateStr = String(row['–î–∞—Ç–∞'] || '').trim();
                    
                    if (!idStr || !/^\d{4}(\/\d)?/.test(idStr)) return;

                    const idNumeric = idToNumeric(idStr);
                    if (idNumeric === null || isNaN(idNumeric)) return;

                    if (idNumeric > globalMaxId) globalMaxId = idNumeric;

                    const date = parseDate(dateStr);
                    if (date) {
                        preBookedData.push({ id: idStr, idNumeric, date: date });
                    }
                });
            }
            
            const preBookedIds = new Set(preBookedData.map(d => d.id));
            let earliestPreBookedDate = null;
            if (preBookedData.length > 0) {
                preBookedData.sort((a, b) => a.date - b.date);
                earliestPreBookedDate = preBookedData[0].date;
            }
            
            const actualMigratedData = [];
            if (migratedData && migratedData.migratedIds && earliestPreBookedDate) {
                migratedData.migratedIds.forEach(id => {
                    if (!preBookedIds.has(id)) {
                        const idNumeric = idToNumeric(id);
                        if (idNumeric !== null && !isNaN(idNumeric)) {
                            actualMigratedData.push({ 
                                id: id, 
                                idNumeric: idNumeric, 
                                date: earliestPreBookedDate 
                            });
                        }
                    }
                });
            }
            
            const allScheduledData = [...preBookedData, ...actualMigratedData];
            if (allScheduledData.length > 0) {
                allScheduledData.sort((a, b) => a.date - b.date);
                
                const nextDate = allScheduledData[0].date;
                const count = allScheduledData.filter(d => d.date.getTime() === nextDate.getTime()).length;
                
                const dateStr = nextDate.toLocaleDateString('uk-UA', { day: 'numeric', month: 'long' });
                
                const infoDiv = document.getElementById('next-day-info');
                if (infoDiv) {
                    infoDiv.textContent = `–ù–∞ –Ω–∞–π–±–ª–∏–∂—á—É –¥–∞—Ç—É (${dateStr}) –∑–∞–ø–∏—Å–∞–Ω–æ: ${count} –æ—Å—ñ–±`;
                }

                const statsDiv = document.getElementById('stats-info');
                if (statsDiv) {
                    statsDiv.textContent = `(–°–µ—Ä–µ–¥–Ω—î "–ó–∞–π—à–æ–≤" –∑–∞ 10 –¥–Ω—ñ–≤: ~${avgDailyCount})`;
                }
            }
            
            const lastHistoricalDateOrdinal = maxDateOrdinal;
            const cutoffOrdinal = lastHistoricalDateOrdinal + 65;
            
            const filteredPreBookedData = preBookedData.filter(d => {
                const ord = toOrdinal(d.date);
                return ord <= cutoffOrdinal;
            });

            const filteredMigratedData = actualMigratedData.filter(d => {
                const ord = toOrdinal(d.date);
                return ord <= cutoffOrdinal;
            });

            const preBookedChartData = filteredPreBookedData.map(d => ({ 
                x: d.date, 
                y: d.idNumeric,
                id: d.id 
            }));
            const migratedChartData = filteredMigratedData.map(d => ({ 
                x: d.date, 
                y: d.idNumeric,
                id: d.id 
            }));

            // –ì—Ä—É–ø—É—î–º–æ —Ç–æ—á–∫–∏ –≤—ñ–¥–≤—ñ–¥—É–≤–∞–Ω–æ—Å—Ç—ñ –∑–∞ ID –¥–ª—è —Ä–µ–≥—Ä–µ—Å—ñ—ó
            // –Ø–∫—â–æ ID –≤—ñ–¥–≤—ñ–¥–∞–≤ –∫—ñ–ª—å–∫–∞ —Ä–∞–∑—ñ–≤, –±–µ—Ä–µ–º–æ —Å–µ—Ä–µ–¥–Ω—é –¥–∞—Ç—É
            const idGroups = new Map();
            allAttendancePoints.forEach(point => {
                if (!idGroups.has(point.id)) {
                    idGroups.set(point.id, { ordinals: [], isLive: false, idNumeric: point.idNumeric });
                }
                idGroups.get(point.id).ordinals.push(point.ordinal);
                // –Ø–∫—â–æ —Ö–æ—á–∞ –± –æ–¥–Ω–µ –≤—ñ–¥–≤—ñ–¥—É–≤–∞–Ω–Ω—è –±—É–ª–æ –∑–∞ –∂–∏–≤–æ—é —á–µ—Ä–≥–æ—é, –º–∞—Ä–∫—É—î–º–æ ID
                if (point.isLive) {
                    idGroups.get(point.id).isLive = true;
                }
            });
            
            const regressionData = Array.from(idGroups.entries()).map(([id, data]) => {
                const avgOrdinal = data.ordinals.reduce((a, b) => a + b, 0) / data.ordinals.length;
                return { id, idNumeric: data.idNumeric, ordinal: avgOrdinal, isLive: data.isLive };
            });
            
            regressionData.sort((a, b) => a.idNumeric - b.idNumeric);

            console.log('Regression data:', regressionData.length, 'groups');
            const X = regressionData.map(d => d.idNumeric); // –ü—Ä–µ–¥–∏–∫—Ç–æ—Ä: ID —á–µ—Ä–≥–∏
            const Y = regressionData.map(d => d.ordinal); // –¶—ñ–ª—å–æ–≤–∞ –∑–º—ñ–Ω–Ω–∞: –î–∞—Ç–∞
            const n = regressionData.length;

            // –í–∞–≥–∏: –µ–∫—Å–ø–æ–Ω–µ–Ω—Ü—ñ–π–Ω–µ –∑–∞—Ç—É—Ö–∞–Ω–Ω—è + –∑–º–µ–Ω—à–µ–Ω–∞ –≤–∞–≥–∞ –¥–ª—è –∂–∏–≤–æ—ó —á–µ—Ä–≥–∏
            const weights = [];
            for (let i = 0; i < n; i++) {
                const val = WEIGHT_EXP_MIN + (i / (n - 1)) * (WEIGHT_EXP_MAX - WEIGHT_EXP_MIN);
                let weight = Math.exp(val);
                
                // –ó–º–µ–Ω—à—É—î–º–æ –≤–∞–≥—É –¥–ª—è —Ç–æ—á–æ–∫ –∂–∏–≤–æ—ó —á–µ—Ä–≥–∏
                if (regressionData[i].isLive) {
                    weight *= LIVE_QUEUE_WEIGHT;
                }
                
                weights.push(weight);
            }

            // 3. Train Model
            const model = weightedLinearRegression(X, Y, weights);

            // 4. Calculate Statistics for Intervals
            let sumW = 0;
            let weightedMeanX = 0;
            for(let i=0; i<n; i++) {
                sumW += weights[i];
                weightedMeanX += weights[i] * X[i];
            }
            weightedMeanX /= sumW;

            let weightedVarX = 0;
            let weightedSumResSq = 0;
            for(let i=0; i<n; i++) {
                weightedVarX += weights[i] * Math.pow(X[i] - weightedMeanX, 2);
                const yPred = model.slope * X[i] + model.intercept;
                const res = Y[i] - yPred;
                weightedSumResSq += weights[i] * res * res;
            }

            const degreesOfFreedom = sumW - 2;
            const mseWeighted = weightedSumResSq / degreesOfFreedom;

            // T-scores
            // For "5% Chance" and "95% Chance" labels, we need the 5th and 95th percentiles.
            // This corresponds to a 90% Confidence Interval (alpha=0.10, two-tailed -> 0.05 in each tail).
            // inv(0.95) gives the 95th percentile.
            const tScore90 = jStat.studentt.inv(0.95, degreesOfFreedom);
            // 50% confidence -> alpha=0.50, two-tailed -> 0.75 (75th percentile)
            const tScore50 = jStat.studentt.inv(0.75, degreesOfFreedom);

            // DRY —Ñ—É–Ω–∫—Ü—ñ—è –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü—ñ—ó –ø—Ä–æ–≥–Ω–æ–∑—ñ–≤
            const generatePredictions = (startId, endId, includeSlashedIds = true) => {
                const allNumericIds = new Set();

                if (includeSlashedIds) {
                    // –î–æ–¥–∞—î–º–æ –≤—Å—ñ —É–Ω—ñ–∫–∞–ª—å–Ω—ñ ID –∑ regressionData (–≤–∫–ª—é—á–Ω–æ –∑—ñ —Å–ª–µ—à–æ–≤–∞–Ω–∏–º–∏)
                    regressionData.forEach(d => allNumericIds.add(d.idNumeric));
                }

                // –î–æ–¥–∞—î–º–æ —Ü—ñ–ª—ñ —á–∏—Å–ª–∞ –¥–ª—è –≥–ª–∞–¥–∫–∏—Ö –ª—ñ–Ω—ñ–π
                const minIdInt = Math.floor(startId);
                const maxIdInt = Math.ceil(endId);
                for (let i = minIdInt; i <= maxIdInt; i++) {
                    allNumericIds.add(i);
                }

                const sortedIds = Array.from(allNumericIds).sort((a, b) => a - b);
                const predPoints = [];

                sortedIds.forEach(qId => {
                    let predOrd = model.slope * qId + model.intercept;

                    const term3 = Math.pow(qId - weightedMeanX, 2) / weightedVarX;
                    const sePred = Math.sqrt(mseWeighted * (1 + 1/sumW + term3));

                    const margin90 = tScore90 * sePred;
                    const margin50 = tScore50 * sePred;

                    let l90 = predOrd - margin90;
                    let h90 = predOrd + margin90;
                    let l50 = predOrd - margin50;
                    let h50 = predOrd + margin50;

                    if (l90 > predOrd) l90 = predOrd;
                    if (h90 < predOrd) h90 = predOrd;
                    if (l50 > predOrd) l50 = predOrd;
                    if (h50 < predOrd) h50 = predOrd;

                    predPoints.push({
                        id: qId,
                        mean: fromOrdinal(predOrd),
                        l90: fromOrdinal(l90),
                        h90: fromOrdinal(h90),
                        l50: fromOrdinal(l50),
                        h50: fromOrdinal(h50)
                    });
                });

                return predPoints;
            };

            // 5. Generate Prediction Data Points
            const minHistoricalId = Math.min(...regressionData.map(d => d.idNumeric));
            const predPoints = generatePredictions(minHistoricalId, targetEndId, true);

            // 6. Chart.js Data Structure

            // –í–∏–∑–Ω–∞—á–∞—î–º–æ –æ—Å—Ç–∞–Ω–Ω—é —ñ—Å—Ç–æ—Ä–∏—á–Ω—É –¥–∞—Ç—É
            const lastHistoricalDate = fromOrdinal(maxDateOrdinal);

            // –ó–Ω–∞—Ö–æ–¥–∏–º–æ –Ω–∞—Å—Ç—É–ø–Ω–∏–π —Ä–æ–±–æ—á–∏–π –¥–µ–Ω—å –ø—ñ—Å–ª—è –æ—Å—Ç–∞–Ω–Ω—å–æ—ó —ñ—Å—Ç–æ—Ä–∏—á–Ω–æ—ó –¥–∞—Ç–∏
            let nextWorkingDate = new Date(lastHistoricalDate);
            nextWorkingDate.setDate(nextWorkingDate.getDate() + 1);

            // –ü—Ä–æ–ø—É—Å–∫–∞—î–º–æ –≤–∏—Ö—ñ–¥–Ω—ñ (5 = —Å—É–±–æ—Ç–∞, 6 = –Ω–µ–¥—ñ–ª—è)
            while (nextWorkingDate.getDay() === 0 || nextWorkingDate.getDay() === 6) {
                nextWorkingDate.setDate(nextWorkingDate.getDate() + 1);
            }

            const nextWorkingTime = nextWorkingDate.getTime();

            // –í–∏–∑–Ω–∞—á–∞—î–º–æ –Ω–∞–π—Ä–∞–Ω—ñ—à—É —ñ—Å—Ç–æ—Ä–∏—á–Ω—É –¥–∞—Ç—É
            const earliestHistoricalDate = fromOrdinal(minDateOrdinal);
            const earliestHistoricalTime = earliestHistoricalDate.getTime();

            // –°—Ç–≤–æ—Ä—é—î–º–æ –ø–æ–≤–Ω—ñ –¥–∞–Ω—ñ –¥–ª—è freezeAtId
            // –í–ê–ñ–õ–ò–í–û: –∑–±–µ—Ä—ñ–≥–∞—î–º–æ —ñ string ID —ñ numeric (–¥–ª—è plotting)
            const allMeanData = predPoints.map(p => ({
                x: p.mean,
                y: p.id,  // numeric –¥–ª—è chart plotting
                id: numericToId(p.id)  // STRING –¥–ª—è display
            }));
            const allL90Data = predPoints.map(p => ({ x: p.l90, y: p.id }));
            const allH90Data = predPoints.map(p => ({ x: p.h90, y: p.id }));
            const allL50Data = predPoints.map(p => ({ x: p.l50, y: p.id }));
            const allH50Data = predPoints.map(p => ({ x: p.h50, y: p.id }));

            console.log('Generated allMeanData points:', allMeanData.length);

            const filterFutureOnly = (arr) => arr.filter(p => p.x.getTime() >= nextWorkingTime);
            const filterFromEarliest = (arr) => arr.filter(p => p.x.getTime() >= earliestHistoricalTime);

            const meanData = filterFromEarliest(allMeanData);
            const l90Data = filterFutureOnly(allL90Data);
            const h90Data = filterFutureOnly(allH90Data);
            const l50Data = filterFutureOnly(allL50Data);
            const h50Data = filterFutureOnly(allH50Data);

            const chart = renderChart(regularPoints, liveQueuePoints, histRanges, preBookedChartData, migratedChartData,
                meanData, l90Data, h90Data, l50Data, h50Data,
                allMeanData, allL90Data, allH90Data, allL50Data, allH50Data, numericToOriginalId,
                model, tScore90, tScore50, weightedMeanX, weightedVarX, mseWeighted, sumW);

            if (chart.pendingFreezeId && chart.freezeAtId) {
                setTimeout(() => {
                    chart.freezeAtId(chart, chart.pendingFreezeId);
                    delete chart.pendingFreezeId;
                }, 100);
            }

            return chart;
        }

        function renderChart(regularPoints, liveQueuePoints, histRanges, preBookedData, migratedData,
                             meanData, l90Data, h90Data, l50Data, h50Data,
                             allMeanData, allL90Data, allH90Data, allL50Data, allH50Data, numericToOriginalId,
                             model, tScore90, tScore50, weightedMeanX, weightedVarX, mseWeighted, sumW) {
            const ctx = document.getElementById('queueChart').getContext('2d');

            // –û–±'—î–¥–Ω—É—î–º–æ –¥–ª—è –∑–≤–æ—Ä–æ—Ç–Ω–æ—ó —Å—É–º—ñ—Å–Ω–æ—Å—Ç—ñ –∑ freezeAtId
            const histData = [...regularPoints, ...liveQueuePoints];

            // Custom Plugin for Variable Width Lines
            const variableWidthLinePlugin = {
                id: 'variableWidthLine',
                beforeDatasetsDraw(chart, args, options) {
                    const { ctx, scales: { x, y } } = chart;
                    const ranges = options.data || [];

                    ctx.save();
                    ctx.lineCap = 'butt';
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';

                    ranges.forEach(range => {
                        if (!range.x || !range.y) return;

                        const xPos = x.getPixelForValue(range.x.getTime());
                        const yMin = y.getPixelForValue(range.y[0]);
                        const yMax = y.getPixelForValue(range.y[1]);

                        // Calculate thickness
                        // Scale: 0.2px per person, clamped between 2px and 30px
                        const thickness = Math.max(2, Math.min(range.thickness * 0.2, 30));

                        ctx.lineWidth = thickness;

                        ctx.beginPath();
                        ctx.moveTo(xPos, yMin);
                        ctx.lineTo(xPos, yMax);
                        ctx.stroke();
                    });

                    ctx.restore();
                }
            };

            // Helper to freeze chart at a specific ID
            // Defined here to access the data arrays via closure
            const freezeAtId = (chart, targetIdString) => {
                // –ö–æ–Ω–≤–µ—Ä—Ç—É—î–º–æ string ‚Üí numeric
                const targetIdNumeric = idToNumeric(targetIdString);
                if (targetIdNumeric === null || isNaN(targetIdNumeric)) {
                    console.error('Invalid ID:', targetIdString);
                    alert(`–ù–µ–≤—ñ—Ä–Ω–∏–π —Ñ–æ—Ä–º–∞—Ç ID: ${targetIdString}`);
                    return;
                }

                console.log('freezeAtId called with STRING ID:', targetIdString);
                console.log('Converted to numeric:', targetIdNumeric);

                // –®—É–∫–∞—î–º–æ —á–∏ —î –≥–æ—Ç–æ–≤–∏–π –ø—Ä–æ–≥–Ω–æ–∑ –¥–ª—è —Ü—å–æ–≥–æ ID
                let predictionData = allMeanData.find(p => Math.abs(p.y - targetIdNumeric) < 0.001);

                if (!predictionData) {
                    console.log('No pre-computed prediction, calculating on-demand for:', targetIdString);

                    // –û–±—á–∏—Å–ª—é—î–º–æ –ø—Ä–æ–≥–Ω–æ–∑ –¥–ª—è —Ü—å–æ–≥–æ ID –¥–∏–Ω–∞–º—ñ—á–Ω–æ
                    let predOrd = model.slope * targetIdNumeric + model.intercept;

                    const term3 = Math.pow(targetIdNumeric - weightedMeanX, 2) / weightedVarX;
                    const sePred = Math.sqrt(mseWeighted * (1 + 1/sumW + term3));

                    const margin90 = tScore90 * sePred;
                    const margin50 = tScore50 * sePred;

                    let l90_ord = predOrd - margin90;
                    let h90_ord = predOrd + margin90;
                    let l50_ord = predOrd - margin50;
                    let h50_ord = predOrd + margin50;

                    // –°—Ç–≤–æ—Ä—é—î–º–æ –æ–±'—î–∫—Ç –∑ –ø—Ä–æ–≥–Ω–æ–∑–æ–º
                    predictionData = {
                        y: targetIdNumeric,
                        id: targetIdString,  // STRING ID
                        x: fromOrdinal(predOrd)
                    };

                    // –î–æ–¥–∞—î–º–æ –¥–æ –º–∞—Å–∏–≤—ñ–≤ –¥–ª—è –ø–æ–¥–∞–ª—å—à–æ–≥–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è
                    const newL90 = { x: fromOrdinal(l90_ord), y: targetIdNumeric };
                    const newH90 = { x: fromOrdinal(h90_ord), y: targetIdNumeric };
                    const newL50 = { x: fromOrdinal(l50_ord), y: targetIdNumeric };
                    const newH50 = { x: fromOrdinal(h50_ord), y: targetIdNumeric };

                    allMeanData.push(predictionData);
                    allL90Data.push(newL90);
                    allH90Data.push(newH90);
                    allL50Data.push(newL50);
                    allH50Data.push(newH50);
                }

                const nearest = predictionData;

                console.log('Using prediction:', nearest.y, '/', nearest.id);

                // Find matching bounds index
                const idx = allMeanData.indexOf(nearest);

                // Check if this ID exists in Historical or Pre-booked data
                let actualDate = null;
                let actualType = null;

                // Check Historical (both regular and live queue) - exact string match
                const histMatch = histData.find(d => d.id === targetIdString);
                if (histMatch) {
                    actualDate = histMatch.x;
                    actualType = '–Ü—Å—Ç–æ—Ä–∏—á–Ω–∞ –¥–∞—Ç–∞';
                } else {
                    // Check Pre-booked - exact string match
                    const preBookedDataset = chart.data.datasets.find(ds => ds.label === '–ü–æ–ø–µ—Ä–µ–¥–Ω—å–æ –∑–∞–ø–∏—Å–∞–Ω—ñ');
                    console.log('Checking pre-booked dataset:', preBookedDataset?.data?.length, 'points');
                    if (preBookedDataset && preBookedDataset.data) {
                        console.log('Looking for:', targetIdString);
                        const preBookedMatch = preBookedDataset.data.find(d => d.id === targetIdString);
                        console.log('Pre-booked match:', preBookedMatch);

                        if (preBookedMatch) {
                            actualDate = preBookedMatch.x;
                            actualType = '–ó–∞–ø–∏—Å –Ω–∞';
                        }
                    }

                    // Check Migrated - numeric match (migrated IDs are integers)
                    if (!actualDate) {
                        const migratedDataset = chart.data.datasets.find(ds => ds.label === '–ü–µ—Ä–µ–Ω–µ—Å–µ–Ω—ñ');
                        if (migratedDataset && migratedDataset.data) {
                            const migratedMatch = migratedDataset.data.find(d => Math.abs(d.y - targetIdNumeric) < 0.001);
                            if (migratedMatch) {
                                actualDate = migratedMatch.x;
                                actualType = '–ü–µ—Ä–µ–Ω–µ—Å–µ–Ω–æ –Ω–∞';
                            }
                        }
                    }
                }

                if (idx !== -1) {
                    chart.frozen = true;
                    chart.options.plugins.tooltip.enabled = false;

                    // –ó–Ω–∞—Ö–æ–¥–∏–º–æ –æ—Ä–∏–≥—ñ–Ω–∞–ª—å–Ω–∏–π string ID (first-class citizen)
                    // –Ø–∫—â–æ —î –≤ —ñ—Å—Ç–æ—Ä–∏—á–Ω–∏—Ö –¥–∞–Ω–∏—Ö - –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ actualIdOriginal
                    // –Ü–Ω–∞–∫—à–µ –∫–æ–Ω–≤–µ—Ä—Ç—É—î–º–æ numeric –Ω–∞–∑–∞–¥ –≤ string
                    const displayId = nearest.id;

                    chart.frozenData = {
                        id: nearest.y,
                        idDisplay: displayId,
                        mean: nearest.x,
                        l90: allL90Data[idx].x,
                        h90: allH90Data[idx].x,
                        l50: allL50Data[idx].x,
                        h50: allH50Data[idx].x,
                        actualDate: actualDate,
                        actualType: actualType
                    };

                    // Update URL with original string format
                    // URLSearchParams.set() automatically handles URL encoding
                    if (window.history.replaceState) {
                        const url = new URL(window.location);
                        url.searchParams.set('id', displayId);
                        window.history.replaceState({}, '', url);
                    }

                    chart.update();
                }
            };

            const freezePlugin = {
                id: 'freezeTooltip',
                defaults: {
                    frozen: false,
                    frozenX: null,
                    frozenY: null,
                    frozenData: null
                },
                afterInit: (chart) => {
                    chart.frozen = false;

                    // Track drag state to prevent click triggering on drag
                    let startX = 0;
                    let startY = 0;

                    chart.canvas.addEventListener('pointerdown', (e) => {
                        startX = e.clientX;
                        startY = e.clientY;
                    });

                    // Bind external input controls
                    const input = document.getElementById('queueInput');
                    const btn = document.getElementById('findBtn');

                    const handleSearch = () => {
                        const inputStr = input.value.trim();
                        if (!inputStr) return;

                        const numericVal = idToNumeric(inputStr);
                        if (numericVal === null || isNaN(numericVal)) {
                            alert('–ù–µ–≤—ñ—Ä–Ω–∏–π —Ñ–æ—Ä–º–∞—Ç –Ω–æ–º–µ—Ä–∞ —á–µ—Ä–≥–∏. –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ —Ñ–æ—Ä–º–∞—Ç: 9999 –∞–±–æ 9999/9');
                            return;
                        }
                        freezeAtId(chart, inputStr);
                    };

                    document.getElementById('resetZoomBtn').addEventListener('click', () => {
                        chart.resetZoom();
                    });

                    btn.addEventListener('click', handleSearch);
                    input.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') handleSearch();
                    });

                    // Check URL for ID param on load
                    const urlParams = new URLSearchParams(window.location.search);
                    const idParam = urlParams.get('id');
                    console.log('idParam', idParam);
                    if (idParam) {
                        // URLSearchParams.get() automatically decodes
                        const val = idToNumeric(idParam);
                        if (val !== null && !isNaN(val)) {
                            input.value = idParam; // Keep original format (4148/1)
                            // Store the pending freeze STRING ID
                            chart.pendingFreezeId = idParam;
                        }
                    }

                    // Handle click to freeze/unfreeze
                    chart.canvas.addEventListener('click', (e) => {
                        // Check distance
                        const dist = Math.hypot(e.clientX - startX, e.clientY - startY);
                        if (dist > 10) return; // Ignore drags > 10px

                        if (chart.frozen) {
                            // Unfreeze
                            chart.frozen = false;
                            chart.options.plugins.tooltip.enabled = true; // Re-enable native

                            // Clear URL param
                            if (window.history.replaceState) {
                                const url = new URL(window.location);
                                url.searchParams.delete('id');
                                window.history.replaceState({}, '', url);
                            }

                            // Remove custom guides
                            // We handle drawing in afterDraw, so just forcing update clears them
                            chart.update();
                        } else {
                            // Freeze
                            // Get data under cursor
                            const points = chart.getElementsAtEventForMode(e, 'nearest', { intersect: false, axis: 'y' }, true);

                            if (points.length) {
                                // Use the click Y value to find target
                                const yValue = chart.scales.y.getValueForPixel(e.offsetY);
                                const targetYNumeric = yValue;
                                
                                // –ó–Ω–∞—Ö–æ–¥–∏–º–æ –Ω–∞–π–±–ª–∏–∂—á—É —Ç–æ—á–∫—É —ñ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ —ó—ó STRING ID
                                const nearestPoint = allMeanData.reduce((prev, curr) => 
                                    Math.abs(curr.y - targetYNumeric) < Math.abs(prev.y - targetYNumeric) ? curr : prev
                                );

                                freezeAtId(chart, nearestPoint.id);
                            }
                        }
                    });
                },
                afterDraw: (chart) => {
                    if (chart.frozen && chart.frozenData) {
                        const ctx = chart.ctx;
                        const data = chart.frozenData;
                        
                        // Get Pixels
                        const yPix = chart.scales.y.getPixelForValue(data.id);
                        const xPixMean = chart.scales.x.getPixelForValue(data.mean.getTime());
                        
                        // Draw Guides
                        ctx.save();
                        ctx.beginPath();
                        ctx.strokeStyle = 'gray';
                        ctx.setLineDash([5, 5]);
                        ctx.lineWidth = 1;
                        
                        // Horizontal Line
                        ctx.moveTo(chart.chartArea.left, yPix);
                        ctx.lineTo(chart.chartArea.right, yPix);
                        
                        // Vertical Line at Mean
                        ctx.moveTo(xPixMean, chart.chartArea.top);
                        ctx.lineTo(xPixMean, chart.chartArea.bottom);
                        
                        // If Actual Data exists, draw Vertical Line at Actual Date
                        if (data.actualDate) {
                            const xPixActual = chart.scales.x.getPixelForValue(data.actualDate.getTime());
                            
                            // Move to actual date
                            ctx.moveTo(xPixActual, chart.chartArea.top);
                            ctx.lineTo(xPixActual, chart.chartArea.bottom);
                            
                            // Highlight the point intersection (optional circle)
                            // ctx.moveTo(xPixActual + 3, yPix);
                            // ctx.arc(xPixActual, yPix, 3, 0, 2 * Math.PI);
                        }
                        
                        ctx.stroke();
                        
                        // Draw Tooltip Box
                        const formatDate = (d) => d.toISOString().split('T')[0];
                        
                        const textLines = [
                            `–ù–æ–º–µ—Ä —É —á–µ—Ä–∑—ñ: ${data.idDisplay}`,
                            `5% —à–∞–Ω—Å—É: ${formatDate(data.l90)}`,
                            `25% —à–∞–Ω—Å—É: ${formatDate(data.l50)}`,
                            `50% —à–∞–Ω—Å—É: ${formatDate(data.mean)}`,
                            `75% —à–∞–Ω—Å—É: ${formatDate(data.h50)}`,
                            `95% —à–∞–Ω—Å—É: ${formatDate(data.h90)}`
                        ];
                        
                        // Add actual date info if available
                        if (data.actualDate) {
                            textLines.unshift(`${data.actualType}: ${formatDate(data.actualDate)}`);
                        } else {
                            textLines.unshift('–ù–µ–º–∞—î –∑–∞–ø–∏—Å—É!');
                        }
                        
                        // Position box fixed at Top-Left of the chart area
                        // This avoids obscuring recent data (usually at bottom-right or top-right)
                        const padding = 10;
                        const lineHeight = 20;
                        const boxWidth = 220; 
                        const boxHeight = textLines.length * lineHeight + padding * 2;
                        
                        // Fixed position: Top-Left corner of the chart area with a small margin
                        let boxX = chart.chartArea.left + 20; 
                        let boxY = chart.chartArea.top + 20;
                        
                        // Background
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.95)'; // Slightly more opaque for readability
                        ctx.strokeStyle = 'black';
                        ctx.setLineDash([]);
                        ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
                        ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);
                        
                        // Text
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'middle';
                        
                        textLines.forEach((line, i) => {
                            // 0: Status (Actual Date or "–ù–µ–º–∞—î –∑–∞–ø–∏—Å—É!")
                            // 1: Queue ID
                            // 4: Mean (50%)
                            let isBold = (i === 0 || i === 1 || i === 4);
                            
                            ctx.font = isBold ? 'bold 12px sans-serif' : '12px sans-serif';
                            
                            if (!data.actualDate && i === 0) {
                                ctx.fillStyle = 'red';
                            } else {
                                ctx.fillStyle = 'black';
                            }
                            
                            ctx.fillText(line, boxX + padding, boxY + padding + i * lineHeight + lineHeight/2);
                        });
                        
                        ctx.restore();
                    }
                }
            };

            // Register custom tooltip positioner
            Chart.Tooltip.positioners.topLeft = function(elements, eventPosition) {
                const chart = this.chart;
                return {
                    x: chart.chartArea.left + 20,
                    y: chart.chartArea.top + 20
                };
            };

            const chart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [
                        {
                            label: '–ó–∞–π—à–ª–∏',
                            data: regularPoints,
                            backgroundColor: 'rgba(0, 0, 0, 0.5)',
                            pointRadius: 2,
                            order: 2
                        },
                        {
                            label: '–ó–∞–π—à–ª–∏ –ø–æ –∂–∏–≤—ñ–π —á–µ—Ä–∑—ñ',
                            data: liveQueuePoints,
                            backgroundColor: 'rgba(34, 139, 34, 0.8)', // Forest Green
                            pointRadius: 2,
                            order: 1
                        },
                        {
                            label: '–ü–æ–ø–µ—Ä–µ–¥–Ω—å–æ –∑–∞–ø–∏—Å–∞–Ω—ñ',
                            data: preBookedData,
                            backgroundColor: 'rgba(255, 165, 0, 0.8)',
                            borderColor: 'rgba(255, 140, 0, 1)',
                            borderWidth: 1,
                            pointRadius: 3,
                            pointStyle: 'rectRot', 
                            order: 0
                        },
                        {
                            label: '–ü–µ—Ä–µ–Ω–µ—Å–µ–Ω—ñ',
                            data: migratedData,
                            backgroundColor: 'rgba(255, 0, 0, 0.8)',
                            borderColor: 'rgba(200, 0, 0, 1)',
                            borderWidth: 1,
                            pointRadius: 3,
                            pointStyle: 'rect',
                            order: 0
                        },
                        {
                            label: '95% –®–∞–Ω—Å',
                            data: h90Data,
                            borderColor: 'rgb(0, 255, 0)', // Bright Green
                            borderWidth: 2,
                            showLine: true,
                            pointRadius: 0, // Hide points for lines
                        },
                        {
                            label: '75% –®–∞–Ω—Å',
                            data: h50Data,
                            borderColor: 'rgba(0, 128, 0, 0.5)', // Dim Green
                            borderWidth: 2,
                            showLine: true,
                            pointRadius: 0, // Hide points for lines
                        },
                        {
                            label: '–ü—Ä–æ–≥–Ω–æ–∑ (50% –®–∞–Ω—Å)',
                            data: meanData,
                            borderColor: 'blue',
                            borderWidth: 2,
                            showLine: true,
                            pointRadius: 0, // Hide points for lines
                        },
                        {
                            label: '25% –®–∞–Ω—Å',
                            data: l50Data,
                            borderColor: 'rgba(139, 0, 0, 0.5)', // Dim Red
                            borderWidth: 2,
                            showLine: true,
                            pointRadius: 0, // Hide points for lines
                        },
                        {
                            label: '5% –®–∞–Ω—Å',
                            data: l90Data,
                            borderColor: 'red', // Red
                            borderWidth: 2,
                            showLine: true,
                            pointRadius: 0, // Hide points for lines
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'week',
                                displayFormats: { week: 'yyyy-MM-dd' }
                            },
                            adapters: { 
                                date: {
                                    locale: window.dateFns ? window.dateFns.locale.uk : undefined
                                }
                            },
                            title: { display: true, text: '–î–∞—Ç–∞' }
                        },
                        y: {
                            title: { display: true, text: '–ù–æ–º–µ—Ä —É —á–µ—Ä–∑—ñ' }
                        }
                    },
                    plugins: {
                        variableWidthLine: {
                            data: histRanges
                        },
                        legend: {
                            // Only show Hist and Mean
                            labels: {
                                filter: function(item, chart) {
                                    // Hide if hidden property is true (which we set for CI)
                                    // Logic: item.hidden is true if user clicked to hide it. 
                                    // But we set 'hidden: true' in dataset config.
                                    // Chart.js default filter shows all unless we override.
                                    
                                    // We want to hide datasets 2,3,4,5 (indices) from legend
                                    // Or check label text
                                    const text = item.text || '';
                                    return !text.includes('%'); 
                                }
                            }
                        },
                        zoom: {
                            pan: {
                                enabled: true,
                                mode: 'xy',
                                threshold: 10,
                            },
                            zoom: {
                                wheel: {
                                    enabled: true,
                                    speed: 0.05, // Default is 0.1, lowering to make it less sensitive
                                },
                                pinch: {
                                    enabled: true
                                },
                                mode: 'xy',
                            }
                        },
                        tooltip: {
                            position: 'topLeft', // Use our custom positioner
                            mode: 'nearest',
                            axis: 'y',
                            intersect: false,
                            callbacks: {
                                title: function(context) {
                                    // Show Queue ID in the tooltip title
                                    if (context.length > 0) {
                                        const id = context[0].raw?.id || 
                                                   numericToOriginalId.get(context[0].parsed.y) ||
                                                   numericToId(context[0].parsed.y);
                                        return `–ù–æ–º–µ—Ä —É —á–µ—Ä–∑—ñ: ${id}`;
                                    }
                                    return '';
                                },
                                label: function(context) {
                                    // Custom tooltip formatting if needed
                                    if (context.dataset.label === '–§–∞–∫—Ç–∏—á–Ω–∞ –≤—ñ–¥–≤—ñ–¥—É–≤–∞–Ω—ñ—Å—Ç—å') {
                                        return `ID: ${context.raw.y}, –î–∞—Ç–∞ –≤—ñ–∑–∏—Ç—É: ${context.raw.x.toISOString().split('T')[0]}`;
                                    }
                                    // Use YYYY-MM-DD format
                                    return `${context.dataset.label}: ${context.raw.x.toISOString().split('T')[0]}`;
                                }
                            }
                        },
                        freezeTooltip: true // Activate our custom plugin
                    },
                    interaction: {
                        mode: 'nearest',
                        axis: 'y',
                        intersect: false
                    }
                },
                plugins: [{
                    id: 'cursorLine',
                    afterDraw: (chart) => {
                        if (chart.tooltip?._active?.length) {
                            const activePoint = chart.tooltip._active[0];
                            const ctx = chart.ctx;
                            const y = activePoint.element.y;
                            const left = chart.chartArea.left;
                            const right = chart.chartArea.right;

                            ctx.save();
                            ctx.beginPath();
                            ctx.moveTo(left, y);
                            ctx.lineTo(right, y);
                            ctx.lineWidth = 1;
                            ctx.strokeStyle = 'red';
                            ctx.stroke();
                            ctx.restore();
                        }
                    }
                }, freezePlugin, variableWidthLinePlugin]
            });
            
            // Store freezeAtId function on chart for later access
            chart.freezeAtId = freezeAtId;
            
            return chart;
        }

    </script>
</body>
</html>
